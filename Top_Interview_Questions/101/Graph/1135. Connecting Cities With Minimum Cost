//C++:
class Solution {
public:
    int minimumCost(int n, vector<vector<int>>& connections) {
        typedef pair<int,int> pii;
        
        vector<vector<pii>> graph(n+1);   // 1-indexed
        
        for(auto& c:connections)
        {
            graph[c[0]].push_back({c[1],c[2]});
            graph[c[1]].push_back({c[0],c[2]});
        }
        
        vector<int> dist(n+1,INT_MAX);
        vector<bool> visited(n+1,false);
        
        priority_queue<pii,vector<pii>,greater<pii>> pq;
        pq.push({0,1});     // <cost, node>
        
        int num_visited = 0, res = 0;
        
        while(!pq.empty() && num_visited<n)
        {
            auto [cost, node] = pq.top();
            pq.pop();
            
            if(visited[node])   continue;
            visited[node] = true;
            
            ++num_visited;
            res += cost;
            
            for (auto& v:graph[node])
            {
                int c = v.second;
                int dst = v.first;
                
                if(!visited[dst] && c<dist[dst])
                {
                    dist[dst] = c;
                    pq.push({c,dst});
                }
            }            
        }
        
        return num_visited==n? res:-1;
    }
};

// TC: O(v+e)
// SC: O(v)
